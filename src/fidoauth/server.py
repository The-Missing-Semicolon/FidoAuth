"""
Serves authentication pages to the end user
"""

import random
import json
import base64
import time
import datetime

from urllib.parse import parse_qs

from fido2.client import CollectedClientData
from fido2.server import U2FFido2Server, PublicKeyCredentialRpEntity
from fido2.webauthn import AuthenticatorData

import auth_tkt
import auth_tkt.ticket

from jinja2 import Environment, PackageLoader

from . import config
from . import common

LOGGER = config.get_logger()

class FidoAuthServer:
    def __init__(self):
        self.challenges = {}
        self.valid_auth_ids = []
        self.j2_env = Environment(loader=PackageLoader("fidoauth", "templates"))


    def login(self, get_query, post_query, remote_addr):
        """
        This is the initial landing page, with the username and password.
        """
        del post_query, remote_addr # Unused

        template = self.j2_env.get_template("login.html.j2")

        back_url = get_query.get("back", [config.DEFAULT_URL])[0]
        auth_id = f"{random.SystemRandom().getrandbits(8*32):064x}"

        # Track known generated authentication ids...
        # Doing this allows for checking for and preventing authentication replays (once the valid id is used, it is
        # removed). This may make it more tedious in the future to handle API based authentication, but that isn't
        # currently a goal for this project. The only other solution I can think of is to track the last X used IDs,
        # which would be more vulnerable to replay if the service was restarted.
        self.valid_auth_ids.append(auth_id)
        while len(self.valid_auth_ids) > config.MAX_VALID_AUTH_IDS:
            self.valid_auth_ids.pop(0)

        return "200 OK", [('Content-type', 'text/html')], template.render(auth_id=auth_id, back_url=back_url).encode()

    def begin_authenticate(self, get_query, post_query, remote_addr):
        """
        This is invoked when the user clicks the "Authenticate" on the login page. If the username and password are
        correct, this will serve the authenticate page, which will proceed with FIDO based authentication.
        """

        #TODO: Add some input sanitization?
        auth_id = post_query["auth_id"][0]
        username = post_query["username"][0]
        password = post_query["password"][0]
        back_url = get_query.get("back", [config.DEFAULT_URL])[0]

        # If the auth_id matches an existing attempt, someone either hit refresh in the middle of the process
        # Kick them back to the log in page to try again
        if username.lower() in self.challenges:
            old_auth_id, _, _ = self.challenges[username.lower()]
            if old_auth_id == auth_id:
                LOGGER.warning("Authentication id reuse for user %s from %s", username, remote_addr)
                raise common.AuthenticationError("Please try again")

        # Ensure the provided auth_id is valid (was recently generated by the login page and wasn't already used)
        # If it's not, it's likely because the user hit back in the middle of the process. Kick them back to the login page
        # to try again.
        if auth_id not in self.valid_auth_ids:
            LOGGER.warning("Invalid authentication id for user %s from %s", username, remote_addr)
            raise common.AuthenticationError("Please try again")

        self.valid_auth_ids.remove(auth_id)

        # Random sleep to attempt to cancel out any timing variance due to various authentication outcomes
        time.sleep(random.SystemRandom().uniform(0.5, 2))

        creds, passhash = common.get_creds_for_user(username)
        if len(creds) == 0:
            LOGGER.warning("Username %s was not found from %s", username, remote_addr)
            raise common.AuthenticationError("Invalid username or password")

        #Check the provided password
        cookies = config.get_authenticator().authenticate(username, password, passhash)
        LOGGER.debug("First factor authenticated for %s from %s", username, remote_addr)

        #Begin FIDO2 authentication
        rp = PublicKeyCredentialRpEntity('FIDO2 Auth Server', config.HOST)
        server = U2FFido2Server(config.HTTP_ORIGIN, rp)
        auth_data, state = server.authenticate_begin(creds)

        self.challenges[username.lower()] = (auth_id, datetime.datetime.now(), state)

        auth_json = {
            'publicKey' : {
                'challenge' : list(auth_data["publicKey"]["challenge"]),
                'rpId': auth_data["publicKey"]["rpId"],
                'allowCredentials': [
                    {
                        'type' : creds["type"],
                        'id' : list(creds["id"]),
                    } for creds in auth_data["publicKey"]["allowCredentials"]
                ],
                'extensions' : {
                    'appid': auth_data["publicKey"]["extensions"]["appid"]
                    }
                }
            }

        template = self.j2_env.get_template("authenticate.html.j2")

        headers = []
        headers.append(('Content-type', 'text/html'))
        for cookie in cookies:
            headers.append(("Set-Cookie", cookie))

        return "200 OK", headers, template.render(auth_id=auth_id, challenge_json=json.dumps(auth_json), username=username.lower(), back_url=back_url).encode()

    def complete_authentication(self, get_query, post_query, remote_addr):
        """
        This is invoked when the user finishes FIDO authentication, and validates the crypto material provided by their
        key. If successful, this will redirect to either the default page or the page that redirected them to
        authentication in the first place.
        """

        auth_id = post_query["auth_id"][0]
        username = post_query["username"][0]
        back_url = get_query.get("back", [config.DEFAULT_URL])[0]

        credential_id = base64.b64decode(post_query["id"][0])
        client_data = CollectedClientData(base64.b64decode(post_query["clientDataJSON"][0]))
        auth_data = AuthenticatorData(base64.b64decode(post_query["authenticatorData"][0]))
        signature = base64.b64decode(post_query["signature"][0])

        rp = PublicKeyCredentialRpEntity('FIDO2 Auth Server', config.HOST)
        server = U2FFido2Server(config.HTTP_ORIGIN, rp)

        creds, _ = common.get_creds_for_user(username)
        (origin_auth_id, auth_start_time, challenge) = self.challenges[username.lower()]

        if auth_id != origin_auth_id:
            raise common.AuthenticationError("Please try again")

        if datetime.datetime.now() - auth_start_time > config.AUTHENTICATION_TIMEOUT:
            raise common.AuthenticationError("Authentication timeout, please try again")

        # Random sleep to attempt to cancel out any timing variance due to various authentication outcomes
        time.sleep(random.SystemRandom().uniform(0.5, 2))

        server.authenticate_complete(
            challenge,
            creds,
            credential_id,
            client_data,
            auth_data,
            signature
        )

        LOGGER.info("Authentication successful for %s from %s", username, remote_addr)
        ticket = auth_tkt.ticket.AuthTkt(config.MOD_TKT_SECRET, username, ip=remote_addr, digest=config.MOD_TKT_DIGEST_TYPE.lower())

        headers = []
        headers.append(('Content-type', 'text/html'))
        headers.append(('Set-Cookie', ticket.cookie("auth_tkt").output(header='')))
        headers.append(('Location', back_url))

        return ("302 Found", headers, "".encode())

    def registration(self, get_query, post_query, remote_addr):
        """
        This is invoked when the user clicks the "Registery Key" on the login page, and will begin the proceess of
        registering a new key.
        """
        del get_query, post_query, remote_addr # Unused
        template = self.j2_env.get_template("register.html.j2")

        return "200 OK", [('Content-type', 'text/html')], template.render().encode()

    def begin_registration(self, get_query, post_query, remote_addr):
        """
        This is invoked when the user clicks the "Begin Registration" on the key registration page. The page that is
        rendered will display the command line for registering the users key.
        """
        del get_query, remote_addr # Ignore

        username = post_query["username"][0]

        rp = PublicKeyCredentialRpEntity('FIDO2 Auth Server', config.HOST)
        server = U2FFido2Server(config.HTTP_ORIGIN, rp)

        #TODO: Fill in some of this data with certificate fields?
        registration_data, state = server.register_begin({ 'id': username.encode(), 'name': username, 'displayName': username })

        with open(config.CHALLENGE_FILE, 'w', encoding="utf8") as f:
            f.write(json.dumps(state))

        registration_json = {
            'publicKey' : {
                'rp' : dict(registration_data.public_key.rp),
                'user' : {
                    'name': registration_data.public_key.user.name,
                    'id': list(registration_data.public_key.user.id),
                    'displayName': registration_data.public_key.user.name
                },
                'challenge' : list(registration_data.public_key.challenge),
                'pubKeyCredParams' : [dict(params) for params in registration_data.public_key.pub_key_cred_params],
                'extensions': registration_data.public_key.extensions
            }
        }

        template = self.j2_env.get_template("registration.html.j2")

        return "200 OK", [('Content-type', 'text/html')], template.render(username=username, challenge_json=json.dumps(registration_json), config=config).encode()

    def logout(self, get_query, post_query, remote_addr):
        """
        This can be redirected to to invalidate the mod_auth_tkt cookie.
        """
        del get_query, post_query, remote_addr # Ignore

        headers = []
        headers.append(('Set-Cookie', "auth_tkt=invalid; Path=/"))

        return "200 OK", headers, "".encode()

    def render_error(self, environ, error_message):
        """
        This page is rendered when ever an error occurs.
        """
        get_query = parse_qs(environ['QUERY_STRING'])
        back_url = get_query.get("back", [config.DEFAULT_URL])[0]

        template = self.j2_env.get_template("error.html.j2")
        return template.render(error_message=error_message, back_url=back_url).encode()
