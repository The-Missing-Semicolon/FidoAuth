import random
import json
import base64
import time
import datetime

from urllib.parse import parse_qs

from fido2.client import CollectedClientData
from fido2.server import U2FFido2Server, PublicKeyCredentialRpEntity
from fido2.webauthn import AuthenticatorData

#TODO: This package is super old... Can I just assemble a ticket manually?
import auth_tkt
import auth_tkt.ticket

import argon2

from jinja2 import Environment, PackageLoader

from . import config
from . import common

CHALLENGE = {}
VALID_AUTH_IDS = []
J2_ENVIRONMENT = Environment(loader=PackageLoader("authenticator", "templates"))

LOGGER = config.GetLogger()

def Login(get_query, post_query, remote_addr):
    template = J2_ENVIRONMENT.get_template("login.html.j2")

    back_url = get_query.get("back", [config.DEFAULT_URL])[0]
    auth_id = '%064x' % random.SystemRandom().getrandbits(8*32)

    # Track known generated authentication ids...
    # Doing this allows for checking for and preventing authentication replays (once the valid id is used, it is
    # removed). This may make it more tedious in the future to handle API based authentication, but that isn't
    # currently a goal for this project. The only other solution I can think of is to track the last X used IDs,
    # which would be more vulnerable to replay if the service was restarted.
    VALID_AUTH_IDS.append(auth_id)
    while len(VALID_AUTH_IDS) > config.MAX_VALID_AUTH_IDS:
        VALID_AUTH_IDS.pop(0)

    return "200 OK", [('Content-type', 'text/html')], template.render(auth_id=auth_id, back_url=back_url).encode()

def BeginAuthenticate(get_query, post_query, remote_addr):
    #TODO: Add some input sanitization?
    auth_id = post_query["auth_id"][0]
    username = post_query["username"][0]
    password = post_query["password"][0]
    back_url = get_query.get("back", [config.DEFAULT_URL])[0]

    # If the auth_id matches an existing attempt, someone either hit refresh in the middle of the process
    # Kick them back to the log in page to try again
    if username.lower() in CHALLENGE:
        old_auth_id, _, _ = CHALLENGE[username.lower()]
        if old_auth_id == auth_id:
            LOGGER.warning("Authentication id reuse for user %s from %s", username, remote_addr)
            raise common.AuthenticationError("Please try again")

    # Ensure the provided auth_id is valid (was recently generated by the login page and wasn't already used)
    # If it's not, it's likely because the user hit back in the middle of the process. Kick them back to the login page
    # to try again.
    if auth_id not in VALID_AUTH_IDS:
        LOGGER.warning("Invalid authentication id for user %s from %s", username, remote_addr)
        raise common.AuthenticationError("Please try again")
    
    VALID_AUTH_IDS.remove(auth_id)

    # Random sleep to attempt to cancel out any timing variance due to various authentication outcomes
    time.sleep(random.SystemRandom().uniform(0.5, 2))

    creds, passhash = common.GetCredsForUser(username)
    if len(creds) > 0 and passhash is not None:
        #Check the provided password
        try:
            common.PASSWORD_HASHER.verify(passhash, password)
            LOGGER.debug("Password for %s accepted from %s", username, remote_addr)
            #TODO: if common.PASSWORD_HASHER.check_needs_rehash(passhash):

            #Begin FIDO2 authentication
            rp = PublicKeyCredentialRpEntity('FIDO2 Auth Server', config.HOST)
            server = U2FFido2Server(config.HTTP_ORIGIN, rp)
            auth_data, state = server.authenticate_begin(creds)

            CHALLENGE[username.lower()] = (auth_id, datetime.datetime.now(), state)

            auth_json = {
                'publicKey' : {
                    'challenge' : [c for c in auth_data["publicKey"]["challenge"]],
                    'rpId': auth_data["publicKey"]["rpId"],
                    'allowCredentials': [
                        {
                            'type' : creds["type"],
                            'id' : [c for c in creds["id"]],
                        } for creds in auth_data["publicKey"]["allowCredentials"]
                    ],
                    'extensions' : {
                        'appid': auth_data["publicKey"]["extensions"]["appid"]
                        }
                    }
                }

            template = J2_ENVIRONMENT.get_template("authenticate.html.j2")

            return "200 OK", [('Content-type', 'text/html')], template.render(auth_id=auth_id, challenge_json=json.dumps(auth_json), username=username.lower(), back_url=back_url).encode()

        except argon2.exceptions.VerifyMismatchError:
            LOGGER.warning("Failed login attempt for user %s from %s", username, remote_addr)
            #TODO: Lock out after some number of attempts....
            raise common.AuthenticationError("Invalid username or password")
    else:
        LOGGER.warning("Username %s was not found from %s", username, remote_addr)
        raise common.AuthenticationError("Invalid username or password")

def CompleteAuthentication(get_query, post_query, remote_addr):
    auth_id = post_query["auth_id"][0]
    username = post_query["username"][0]
    back_url = get_query.get("back", [config.DEFAULT_URL])[0]
    
    credential_id = base64.b64decode(post_query["id"][0])
    client_data = CollectedClientData(base64.b64decode(post_query["clientDataJSON"][0]))
    auth_data = AuthenticatorData(base64.b64decode(post_query["authenticatorData"][0]))
    signature = base64.b64decode(post_query["signature"][0])

    rp = PublicKeyCredentialRpEntity('FIDO2 Auth Server', config.HOST)
    server = U2FFido2Server(config.HTTP_ORIGIN, rp)

    creds, _ = common.GetCredsForUser(username)
    (origin_auth_id, auth_start_time, challenge) = CHALLENGE[username.lower()]

    if auth_id != origin_auth_id:
        raise common.AuthenticationError("Please try again")
    
    if datetime.datetime.now() - auth_start_time > config.AUTHENTICATION_TIMEOUT:
        raise common.AuthenticationError("Authentication timeout, please try again")

    # Random sleep to attempt to cancel out any timing variance due to various authentication outcomes
    time.sleep(random.SystemRandom().uniform(0.5, 2))

    server.authenticate_complete(
        challenge,
        creds,
        credential_id,
        client_data,
        auth_data,
        signature
    )

    LOGGER.info("Authentication successful for %s from %s", username, remote_addr)
    ticket = auth_tkt.ticket.AuthTkt(config.MOD_TKT_SECRET, username, ip=remote_addr, digest=config.MOD_TKT_DIGEST_TYPE.lower())

    headers = []
    headers.append(('Content-type', 'text/html'))
    headers.append(('Set-Cookie', ticket.cookie("auth_tkt").output(header='')))
    headers.append(('Location', back_url))

    return ("302 Found", headers, "".encode())

def Registration(get_query, post_query, remote_addr):
    template = J2_ENVIRONMENT.get_template("register.html.j2")

    return "200 OK", [('Content-type', 'text/html')], template.render().encode()

def BeginRegistration(get_query, post_query, remote_addr):
    username = post_query["username"][0]

    rp = PublicKeyCredentialRpEntity('FIDO2 Auth Server', config.HOST)
    server = U2FFido2Server(config.HTTP_ORIGIN, rp)

    #TODO: Fill in some of this data with certificate fields?
    registration_data, state = server.register_begin({ 'id': username.encode(), 'name': username, 'displayName': username })

    with open(config.CHALLENGE_FILE, 'w') as f:
        f.write(json.dumps(state))

    registration_json = {
        'publicKey' : {
            'rp' : dict(registration_data.public_key.rp),
            'user' : {
                'name': registration_data.public_key.user.name,
                'id': [c for c in registration_data.public_key.user.id],
                'displayName': registration_data.public_key.user.name
            },
            'challenge' : [c for c in registration_data.public_key.challenge],
            'pubKeyCredParams' : [dict(params) for params in registration_data.public_key.pub_key_cred_params],
            'extensions': registration_data.public_key.extensions
        }
    }

    template = J2_ENVIRONMENT.get_template("registration.html.j2")

    return "200 OK", [('Content-type', 'text/html')], template.render(username=username, challenge_json=json.dumps(registration_json), config=config).encode()

def RenderError(environ, error_message):
    get_query = parse_qs(environ['QUERY_STRING'])
    back_url = get_query.get("back", [config.DEFAULT_URL])[0]

    template = J2_ENVIRONMENT.get_template("error.html.j2")
    return template.render(error_message=error_message, back_url=back_url).encode()
